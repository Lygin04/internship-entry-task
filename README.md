## Описание выполненного задания
Приложение запускается на порту `8080`. Для тестирования доступен swagger по следующей ссылке 
http://localhost:8080/swagger/index.html

### Используемые технологии

- .NET 9
- PostgreSQL
- Dapper
- Docker

`docker-compose -f compose.override.yml up -d; dotnet test`
### Запуск приложения
Приложение запускается командой `docker-compose -f compose.yaml up -d`. При первом запуске
выполняется миграция базы данных при помощи DbUp.

### В данном проекте доступно 4 контрольной точки

- POST /v1/games/create Создает новую игру с параметрами из переменных окружения. Переменные окружения можно поменять в 
файле `compose.yaml`. `BOARD_SIZE`, `WIN_CONDITION` размер поля и условия победы
- GET /v1/games/{id} Возвращает игру по ее идентификатору
- POST /v1/games/{id}/move Делает ход игры, принимая идентификатор и координаты в теле запроса
- GET /health Возвращает состояние приложения и базы данных

### Описание принципа работы приложения
Перед запуском приложения можно настроить параметры в файле `compose.yaml`. В нем задаются `BOARD_SIZE` и `WIN_CONDITION`
— размер игрового поля и условия победы. После запуска все игры будут проходить по этим настройкам. Изменить их можно в 
любое время, но для этого потребуется перезапуск.

Конечная точка для хода обоих игроков одна и та же. Приложение автоматически переключает ход между игроками. Условия 
победы проверяются не сразу. Программа сначала рассчитывает минимальное количество ходов, необходимое для победы одного 
из игроков, и только после этого начинает проверку.

Для проверки победы разработан алгоритм, который анализирует не все поле целиком, а лишь те позиции, которые могут 
привести к победе после последнего хода. Программа проверяет горизонтальную, вертикальную, диагональную и 
побочно-диагональную линии возле с центром точки последнего хода. После завершения игры сделать ход невозможно.

Concurrency & идемпотентность реализована с помощью сохранения всех ходов в базу данных и транзакциями.
Persistence crash-safe реализованна также с помощью сохранения состояния игры в базу данных после каждого хода.
Негативные тесты тоже реализованы и доступны для проверки по инструкции выше.

### Тестирование проекта
В рамках задания были разработаны unit тесты и интеграционные тесты. Для интеграционных тестов запускается тестовая база
данных чтобы не засорять основную. Перед запуском тестов обязательно надо запустить базу данных. Следующая команда 
запустит тестовую базу данных и после этого сами тесты `docker-compose -f compose.override.yml up -d; dotnet test`.
Также тесты выполняются в github во вкладке Action после каждого пуша в репозиторий.

### Описание выбранной архитектуры
Проект использует классическую многослойную архитектуру (Layered Architecture), которая помогает поддерживать чистый, 
гибкий и хорошо тестируемый код.
#### Domain (Доменный слой)
Содержит основные бизнес-объекты (Entities) и интерфейсы репозиториев. Здесь нет зависимостей от инфраструктуры или 
фреймворков. Отвечает за бизнес-логику на уровне сущностей.

#### Application (Сервисный слой)
Реализует бизнес-логику приложения, orchestrates (координирует) вызовы репозиториев и сервисов. Зависит от Domain. В 
этом слое находятся сервисы, которые реализуют use-case'ы (например: GameService).

#### Infrastructure (Инфраструктурный слой)
Реализация взаимодействия с внешними системами: база данных (через Dapper), миграция базы данных. Конкретные реализации 
интерфейсов из Domain.

#### Api (Веб-слой)
Точка входа приложения (REST API). Использует контроллеры для обработки HTTP-запросов и возврата ответов. Вызывает 
сервисы из Application.

#### Models (Модели передачи данных)
DTO-модели (Request/Response), которые используются для общения между API и клиентами. Вынесены отдельно для удобства и 
разделения с доменными сущностями.

# Задача #1 на стажировку backend разработчик Банка C#/PostgreSQL

Спроектируйте и реализуйте REST API для игры в крестики нолики

Должен поддерживаться формат сообщений json. 

## Описание

Для разработки сайта и мобильного приложения для игры в крестики нолики NxN (N >= 3) для двух игроков требуется реализовать web api. Игра проходит по обычным правилам, за исключением одного - каждый третий ход игры существует вероятность 10%, что поставится значок противника.

- создание новой игры,
- ходы двух игроков,
- фиксация победы или ничьей.
- размер поля и условия победы задаются через переменные окружения

Платформа

- **Платформа:** .NET 9
- **Хранилище:** любая СУБД (можно файловую).

## Формат решения

### Обязательно:

- Вы делаете форк от этого репозитория и предоставляете ссылку PR с вашим решением
- проект должен быть выложен на GitHub и открываться с помощьюм VS2022
- в readme.md репозитория или на выделенной онлайн странице должно быть описание API и принятых архитектурных решений
- проект собирается в докер и разворачиватся в рабочее состояние docker-compose up

## Автоматическая проверка

### Запуск

- В репозитории есть **`Dockerfile`** (обязательно) и при необходимости **`docker-compose.yml`**.
- Приложение внутри контейнера слушает **порт 8080**.
- На запрос `GET /health` отвечает `200 OK`.

### Тесты

- Есть интеграционные и unit тесты
- Минимальное покрытие кода — **30 %**.
- Запуск тестов в CI и локально — `dotnet test` (или аналогичная команда).

### Дополнительные тонкости (обязательно)

- **Concurrency & идемпотентность**  
   При гонке двух `POST /moves` с одинаковым телом второй запрос обязан вернуть 200 OK и тот же `ETag`.

- **Persistence crash-safe**  
   После перезапуска контейнера мы выполняем `GET /games/{id}` и делаем следующий ход. Сессия игрока сохраняется.

- **Негативные тесты**  
   Любой некорректный JSON (пример ниже) → HTTP 400 (RFC 7807)

## Цель задания

Предоставить кандидату возможность продемонстрировать свои знания
